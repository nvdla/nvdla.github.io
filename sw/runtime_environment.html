<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Runtime environment &#8212; NVDLA Documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/nvdla.css?v=907781f7" />
    <link rel="stylesheet" type="text/css" href="../_static/styles.css?v=af91e327" />
    <script src="../_static/documentation_options.js?v=7026087e"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Test applications" href="test_application.html" />
    <link rel="prev" title="Compiler library" href="compilation_tool.html" />
 
<style>
  #onetrust-banner-sdk.otFloatingRounded {
    margin-left:-10px !important;
    margin-bottom:-10px !important;
    width: 100% !important;
    max-width: 100% !important;
  }
</style>
<script src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script>
<!-- OneTrust Cookies Consent Notice start for nvdla.org -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="018f0667-2548-7720-98d6-fef08f0e7436" ></script>
<script type="text/javascript">
function OptanonWrapper() {
        var event = new Event('bannerLoaded');
        window.dispatchEvent(event);
    }
</script>
<script type="text/javascript" src="https://images.nvidia.com/aem-dam/Solutions/ot-js/ot-custom.js"></script>
<!-- OneTrust Cookies Consent Notice end for nvdla.org -->
  </head><body>
<header class="navbar">
  <nav class="container navbar navbar-light bg-faded">
    <a class="navbar-brand" href="https://www.nvidia.com/">
      <div class="logo"></div>
    </a>
  </nav>
</header>

    <div class="related" role="navigation" aria-label="related navigation">
      <div class="container">
      <div class="row">
      <h3>Navigation</h3>
      <ul>
        <li class="right first">
          <a href="test_application.html" title="Test applications"
             accesskey="N">next</a></li>
        <li class="right">
          <a href="compilation_tool.html" title="Compiler library"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">NVDLA Open Source Project</a>&#187;</li>
        <li class="nav-item nav-item-1"><a href="../contents.html">Documentation</a>&#187;</li>
          <li class="nav-item nav-item-2"><a href="contents.html" accesskey="U">Software Manual</a>&#187;</li> 
      </ul>
      </div>
      </div>
    </div>
  <div class="document">
    <div class="container">
      <div class="row">
        <div class="col-xs-12 col-md-9">
          
  <section id="runtime-environment">
<span id="id1"></span><h1>Runtime environment<a class="headerlink" href="#runtime-environment" title="Link to this heading">¶</a></h1>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/runtime_environment.png"><img alt="../_images/runtime_environment.png" src="../_images/runtime_environment.png" style="width: 484.4px; height: 355.59999999999997px;" /></a>
</figure>
<p>The runtime envionment includes software to run a compiled neural network on compatible <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> hardware. It consists of 2 parts:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#user-mode-driver"><span class="std std-ref">User Mode Driver</span></a> - This is the main interface to the application. As detailed in the <a class="reference internal" href="compilation_tool.html#compiler-library"><span class="std std-ref">Compiler library</span></a>, after parsing and compiling the neural network layer by layer, the compiled output is stored in a file format called <a class="reference internal" href="../glossary.html#term-NVDLA-Loadable"><span class="xref std std-term">NVDLA Loadable</span></a>. User mode runtime driver loads this loadable and submits inference jobs to the <a class="reference internal" href="#kernel-mode-driver"><span class="std std-ref">Kernel Mode Driver</span></a>.</p></li>
<li><p><a class="reference internal" href="#kernel-mode-driver"><span class="std std-ref">Kernel Mode Driver</span></a> - Consists of kernel mode driver and engine scheduler that does the work of scheduling the compiled network on <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> and programming the <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> registers to configure each functional block.</p></li>
</ul>
<p>The runtime environment uses the stored representation of the network saved as <a class="reference internal" href="../glossary.html#term-NVDLA-Loadable"><span class="xref std std-term">NVDLA Loadable</span></a> image. From point of view of the <a class="reference internal" href="../glossary.html#term-NVDLA-Loadable"><span class="xref std std-term">NVDLA Loadable</span></a>, each compiled “layer” in software is loadable on a functional block in the <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> implementation. Each layer includes information about its dependencies on other layers, the buffers that it uses for inputs and outputs in memory, and the specific configuration of each functional block used for its execution. Layers are linked together through a dependency graph, which the engine scheduler uses for scheduling layers. The format of an <a class="reference internal" href="../glossary.html#term-NVDLA-Loadable"><span class="xref std std-term">NVDLA Loadable</span></a> is standardized across compiler implementations and UMD implementations. All implementations that comply with the <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> standard should be able to at least interpret any <a class="reference internal" href="../glossary.html#term-NVDLA-Loadable"><span class="xref std std-term">NVDLA Loadable</span></a> image, even if the implementation may not have some features that are required to run inferencing using that loadable image.</p>
<p>Both the <a class="reference internal" href="#user-mode-driver"><span class="std std-ref">User Mode Driver</span></a> stack and the <a class="reference internal" href="#kernel-mode-driver"><span class="std std-ref">Kernel Mode Driver</span></a> stack exist as defined APIs, and are expected to be wrapped with a system portability layer. Maintaining core implementations within a portability layer is expected to require relatively few changes. This expedites any effort that may be necessary to run the <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a> software-stack on multiple platforms. With the appropriate portability layers in place, the same core implementations should compile as readily on both Linux and FreeRTOS. Similarly, on “headed” implementations that have a microcontroller closely coupled to <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a>, the existence of the portability layer makes it possible to run the same kernel mode driver on that microcontroller as would have run on the main CPU in a “headless” implementation that had no such companion microcontroller.</p>
<section id="user-mode-driver">
<span id="id2"></span><h2>User Mode Driver<a class="headerlink" href="#user-mode-driver" title="Link to this heading">¶</a></h2>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/umd.png"><img alt="../_images/umd.png" src="../_images/umd.png" style="width: 340.9px; height: 355.59999999999997px;" /></a>
</figure>
<p>UMD provides standard <a class="reference internal" href="#umd-api"><span class="std std-ref">Application Programming Interface</span></a> (API) for processing loadable images, binding input and output tensors to memory locations, and submitting inference jobs to KMD. This layer loads the network into memory in a defined set of data structures, and passes it to the KMD in an implementation-defined fashion. On Linux, for instance, this could be an <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code>, passing data from the user-mode driver to the kernel-mode driver; on a single-process system in which the KMD runs in the same environment as the UMD, this could be a simple function call. Low-level functions are implemented in <a class="reference internal" href="#user-mode-driver"><span class="std std-ref">User Mode Driver</span></a></p>
<hr class="docutils" />
<section id="application-programming-interface">
<span id="umd-api"></span><h3>Application Programming Interface<a class="headerlink" href="#application-programming-interface" title="Link to this heading">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="runtime-interface">
<h4>Runtime Interface<a class="headerlink" href="#runtime-interface" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>This is the interface for runtime library. It implements functions to process loadable buffer passed from application after reding it from file, allocate memory for tensors and intermediate buffers, prepare synchronization points and finally submit inference job to KMD. Inference job submitted to KMD is referred as DLA task.</p>
</div></blockquote>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntimeE">
<span id="_CPPv3N5nvdla5nvdla8IRuntimeE"></span><span id="_CPPv2N5nvdla5nvdla8IRuntimeE"></span><span id="nvdla::nvdla::IRuntime"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">IRuntime</span></span></span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Submitting task for inference using runtime interface includes below steps</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#create-runtime-instance"><span class="std std-ref">Create NVDLA runtime instance</span></a></p></li>
<li><p><a class="reference internal" href="#device-information"><span class="std std-ref">Get NVDLA device information</span></a></p></li>
<li><p><a class="reference internal" href="#load-network"><span class="std std-ref">Load network data</span></a></p></li>
<li><p><a class="reference internal" href="#tensor-information"><span class="std std-ref">Get input and output tensors information</span></a></p></li>
<li><p><a class="reference internal" href="#update-tensors"><span class="std std-ref">Update input and output tensors information</span></a></p></li>
<li><p><a class="reference internal" href="#allocate-memory"><span class="std std-ref">Allocate memory for input and output tensors</span></a></p></li>
<li><p><a class="reference internal" href="#bind-tensor"><span class="std std-ref">Bind memory handle with tensor</span></a></p></li>
<li><p><a class="reference internal" href="#submit-task"><span class="std std-ref">Submit task for inference</span></a></p></li>
<li><p><a class="reference internal" href="#unload-network"><span class="std std-ref">Unload network resources</span></a></p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="create-nvdla-runtime-instance">
<span id="create-runtime-instance"></span><h4>Create NVDLA runtime instance<a class="headerlink" href="#create-nvdla-runtime-instance" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla13createRuntimeEv">
<span id="_CPPv3N5nvdla5nvdla13createRuntimeEv"></span><span id="_CPPv2N5nvdla5nvdla13createRuntimeEv"></span><span id="nvdla::nvdla::createRuntime"></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">createRuntime</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla13createRuntimeEv" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>IRuntime object</p>
</dd>
</dl>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="get-nvdla-device-information">
<span id="device-information"></span><h4>Get NVDLA device information<a class="headerlink" href="#get-nvdla-device-information" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime13getMaxDevicesEv">
<span id="_CPPv3N5nvdla5nvdla8IRuntime13getMaxDevicesEv"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime13getMaxDevicesEv"></span><span id="nvdla::nvdla::IRuntime::getMaxDevices"></span><span class="n"><span class="pre">NvU16</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getMaxDevices</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime13getMaxDevicesEv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get maximum number of device supported by HW configuration. Runtime driver supports submitting inference jobs to  multiple DLA devices. User application can select device to use. One task can’t splitted across devices but one task can be submitted to only one devices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Maximum number of devices supported</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime13getNumDevicesEv">
<span id="_CPPv3N5nvdla5nvdla8IRuntime13getNumDevicesEv"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime13getNumDevicesEv"></span><span id="nvdla::nvdla::IRuntime::getNumDevices"></span><span class="n"><span class="pre">NvU16</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getNumDevices</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime13getNumDevicesEv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get number of available devices from the maximum number of devices supported by HW configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of available devices</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="load-network-data">
<span id="load-network"></span><h4>Load network data<a class="headerlink" href="#load-network-data" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime4loadEPK4NvU8i">
<span id="_CPPv3N5nvdla5nvdla8IRuntime4loadEPK4NvU8i"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime4loadEPK4NvU8i"></span><span id="nvdla::nvdla::IRuntime::load__NvU8CP.i"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">load</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">NvU8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">instance</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime4loadEPK4NvU8i" title="Link to this definition">¶</a><br /></dt>
<dd><p>Parse loadable from buffer and update ILoadable with information required to create task</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>buf</strong> – Loadable image buffer</p></li>
<li><p><strong>instance</strong> – Device instance to load this network</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="get-input-and-output-tensors-information">
<span id="tensor-information"></span><h4>Get input and output tensors information<a class="headerlink" href="#get-input-and-output-tensors-information" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime18getNumInputTensorsEPi">
<span id="_CPPv3N5nvdla5nvdla8IRuntime18getNumInputTensorsEPi"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime18getNumInputTensorsEPi"></span><span id="nvdla::nvdla::IRuntime::getNumInputTensors__iP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getNumInputTensors</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">input_tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime18getNumInputTensorsEPi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get number of network’s input tensors from loadable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_tensors</strong> – Pointer to update number of input tensors value</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime18getInputTensorDescEiP11NvDlaTensor">
<span id="_CPPv3N5nvdla5nvdla8IRuntime18getInputTensorDescEiP11NvDlaTensor"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime18getInputTensorDescEiP11NvDlaTensor"></span><span id="nvdla::nvdla::IRuntime::getInputTensorDesc__i.NvDlaTensorP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getInputTensorDesc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="n"><span class="pre">NvDlaTensor</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime18getInputTensorDescEiP11NvDlaTensor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get network’s input tensor descriptor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>tensors</strong> – Tensor descriptor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime19getNumOutputTensorsEPi">
<span id="_CPPv3N5nvdla5nvdla8IRuntime19getNumOutputTensorsEPi"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime19getNumOutputTensorsEPi"></span><span id="nvdla::nvdla::IRuntime::getNumOutputTensors__iP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getNumOutputTensors</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">output_tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime19getNumOutputTensorsEPi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get number of network’s output tensors from loadable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output_tensors</strong> – Pointer to update number of output tensors value</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime19getOutputTensorDescEiP11NvDlaTensor">
<span id="_CPPv3N5nvdla5nvdla8IRuntime19getOutputTensorDescEiP11NvDlaTensor"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime19getOutputTensorDescEiP11NvDlaTensor"></span><span id="nvdla::nvdla::IRuntime::getOutputTensorDesc__i.NvDlaTensorP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">getOutputTensorDesc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="n"><span class="pre">NvDlaTensor</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime19getOutputTensorDescEiP11NvDlaTensor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get network’s output tensor descriptor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>tensors</strong> – Tensor descriptor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="update-input-and-output-tensors-information">
<span id="update-tensors"></span><h4>Update input and output tensors information<a class="headerlink" href="#update-input-and-output-tensors-information" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Required only if tensor information is changed, not all parameters can be changed</p>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime18setInputTensorDescEiPK11NvDlaTensor">
<span id="_CPPv3N5nvdla5nvdla8IRuntime18setInputTensorDescEiPK11NvDlaTensor"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime18setInputTensorDescEiPK11NvDlaTensor"></span><span id="nvdla::nvdla::IRuntime::setInputTensorDesc__i.NvDlaTensorCP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">setInputTensorDesc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">NvDlaTensor</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime18setInputTensorDescEiPK11NvDlaTensor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set network’s input tensor descriptor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>tensors</strong> – Tensor descriptor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime19setOutputTensorDescEiPK11NvDlaTensor">
<span id="_CPPv3N5nvdla5nvdla8IRuntime19setOutputTensorDescEiPK11NvDlaTensor"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime19setOutputTensorDescEiPK11NvDlaTensor"></span><span id="nvdla::nvdla::IRuntime::setOutputTensorDesc__i.NvDlaTensorCP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">setOutputTensorDesc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">NvDlaTensor</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tensors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime19setOutputTensorDescEiPK11NvDlaTensor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set network’s output tensor descriptor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>tensors</strong> – Tensor descriptor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="allocate-memory-for-input-and-output-tensors">
<span id="allocate-memory"></span><h4>Allocate memory for input and output tensors<a class="headerlink" href="#allocate-memory-for-input-and-output-tensors" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla20allocateSystemMemoryEPPv5NvU64PPv">
<span id="_CPPv3N5nvdla20allocateSystemMemoryEPPv5NvU64PPv"></span><span id="_CPPv2N5nvdla20allocateSystemMemoryEPPv5NvU64PPv"></span><span id="nvdla::allocateSystemMemory__voidPP.NvU64.voidPP"></span><span class="n"><span class="pre">NvDlaError</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allocateSystemMemory</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">h_mem</span></span>, <span class="n"><span class="pre">NvU64</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pData</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla20allocateSystemMemoryEPPv5NvU64PPv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate DMA memory accessible by NVDLA for input and output tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h_mem</strong> – void pointer to store memory handle address</p></li>
<li><p><strong>size</strong> – Size of memory to allocate</p></li>
<li><p><strong>pData</strong> – Virtual address for allocated memory</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="bind-memory-handle-with-tensor">
<span id="bind-tensor"></span><h4>Bind memory handle with tensor<a class="headerlink" href="#bind-memory-handle-with-tensor" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime15bindInputTensorEiPv">
<span id="_CPPv3N5nvdla5nvdla8IRuntime15bindInputTensorEiPv"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime15bindInputTensorEiPv"></span><span id="nvdla::nvdla::IRuntime::bindInputTensor__i.voidP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">bindInputTensor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">hMem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime15bindInputTensorEiPv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Bind network’s input tensor to memory handle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>hMem</strong> – DLA memory handle returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">allocateSystemMemory()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime16bindOutputTensorEiPv">
<span id="_CPPv3N5nvdla5nvdla8IRuntime16bindOutputTensorEiPv"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime16bindOutputTensorEiPv"></span><span id="nvdla::nvdla::IRuntime::bindOutputTensor__i.voidP"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">bindOutputTensor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">id</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">hMem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime16bindOutputTensorEiPv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Bind network’s output tensor to memory handle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – Tensor ID</p></li>
<li><p><strong>hMem</strong> – DLA memory handle returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">allocateSystemMemory()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="submit-task-for-inference">
<span id="submit-task"></span><h4>Submit task for inference<a class="headerlink" href="#submit-task-for-inference" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime6submitEv">
<span id="_CPPv3N5nvdla5nvdla8IRuntime6submitEv"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime6submitEv"></span><span id="nvdla::nvdla::IRuntime::submit"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">submit</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime6submitEv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Submit task for inference, it is blocking call</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="unload-network-resources">
<span id="unload-network"></span><h4>Unload network resources<a class="headerlink" href="#unload-network-resources" title="Link to this heading">¶</a></h4>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5nvdla5nvdla8IRuntime6unloadEi">
<span id="_CPPv3N5nvdla5nvdla8IRuntime6unloadEi"></span><span id="_CPPv2N5nvdla5nvdla8IRuntime6unloadEi"></span><span id="nvdla::nvdla::IRuntime::unload__i"></span><span class="n"><span class="pre">NvError</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nvdla</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE" title="nvdla::nvdla::IRuntime"><span class="n"><span class="pre">IRuntime</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">unload</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">instance</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5nvdla5nvdla8IRuntime6unloadEi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unload network data, free all resourced used for network if no plan to submit inference using same network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instance</strong> – Device instance from where to unload</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">NvError</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="portability-layer">
<span id="umd-layer"></span><h3>Portability layer<a class="headerlink" href="#portability-layer" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Portability layer for UMD implements functions to access NVDLA device, allocate DMA memory and submit task to low level driver. For this functionality UMD has to communicate with KMD and the communication interface is OS dependent. Portability layer abstracts this OS dependent interface.</p>
</div></blockquote>
<dl class="c type">
<dt class="sig sig-object c" id="c.NvError">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvError</span></span></span><a class="headerlink" href="#c.NvError" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enum for error codes</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.NvDlaHeap">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaHeap</span></span></span><a class="headerlink" href="#c.NvDlaHeap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory heap to allocate memory, NVDLA supports two memory interfaces. Generally these interfaces are connected to DRAM (System memory) and internal SRAM. KMD can maintain separate heaps for allocation depending on memory type.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.NvDlaMemDesc">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaMemDesc</span></span></span><a class="headerlink" href="#c.NvDlaMemDesc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory descriptor, it includes memory handle and buffer size.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.NvDlaTask">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaTask</span></span></span><a class="headerlink" href="#c.NvDlaTask" title="Link to this definition">¶</a><br /></dt>
<dd><p>DLA task structure. Runtime driver populates it using information from loadable and is used by portability layer to submit inference task to KMD in an implementation define manner.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaInitialize">
<a class="reference internal" href="#c.NvError" title="NvError"><span class="n"><span class="pre">NvError</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaInitialize</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaInitialize" title="Link to this definition">¶</a><br /></dt>
<dd><p>This API should initialize session for portability layer which may include allocating some structure required to maintain information such such device context, file descriptors. This function can be empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – [out] Pointer to update session handle address. This address is passed in any APIs called after this which can be used by portability layer to recover session information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#c.NvError" title="NvError"><code class="xref c c-type docutils literal notranslate"><span class="pre">NvError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaDestroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaDestroy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaDestroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release all session resources</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaOpen">
<a class="reference internal" href="#c.NvError" title="NvError"><span class="n"><span class="pre">NvError</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaOpen</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span>, <span class="n"><span class="pre">NvU32</span></span><span class="w"> </span><span class="n"><span class="pre">instance</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaOpen" title="Link to this definition">¶</a><br /></dt>
<dd><p>This API should open DLA device instance. .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
<li><p><strong>instance</strong> – NVDLA instance to use if there are more than one instances in SoC</p></li>
<li><p><strong>device_handle</strong> – [out] Pointer to update device context. It is used to obtain device information required for further callbacks which need device context.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#c.NvError" title="NvError"><code class="xref c c-type docutils literal notranslate"><span class="pre">NvError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaClose">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaClose</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaClose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close DLA device instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
<li><p><strong>device_handle</strong> – Device handle address obtained from <a class="reference internal" href="#c.NvDlaOpen" title="NvDlaOpen"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaOpen()</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaSubmit">
<a class="reference internal" href="#c.NvError" title="NvError"><span class="n"><span class="pre">NvError</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaSubmit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_handle</span></span>, <a class="reference internal" href="#c.NvDlaTask" title="NvDlaTask"><span class="n"><span class="pre">NvDlaTask</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tasks</span></span>, <span class="n"><span class="pre">NvU32</span></span><span class="w"> </span><span class="n"><span class="pre">num_tasks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaSubmit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Submit inference task to KMD</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
<li><p><strong>device_handle</strong> – Device handle address obtained from <a class="reference internal" href="#c.NvDlaOpen" title="NvDlaOpen"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaOpen()</span></code></a></p></li>
<li><p><strong>tasks</strong> – Lists of tasks to submit for inferencing</p></li>
<li><p><strong>num_tasks</strong> – Number of tasks to submit</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#c.NvError" title="NvError"><code class="xref c c-type docutils literal notranslate"><span class="pre">NvError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaAllocMem">
<a class="reference internal" href="#c.NvError" title="NvError"><span class="n"><span class="pre">NvError</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaAllocMem</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mem_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pData</span></span>, <span class="n"><span class="pre">NvU32</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.NvDlaHeap" title="NvDlaHeap"><span class="n"><span class="pre">NvDlaHeap</span></span></a><span class="w"> </span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaAllocMem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate, pin and map DLA engine accessible memory. For example, in case of systems where DLA is behind IOMMU then this call should ensure that IOMMU mappings are created for this memory. In case of Linux, internal implementation can use readily available frameworks such as ION for this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
<li><p><strong>device_handle</strong> – Device handle address obtained from <a class="reference internal" href="#c.NvDlaOpen" title="NvDlaOpen"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaOpen()</span></code></a></p></li>
<li><p><strong>mem_handle</strong> – [out] Memory handle updated by this function</p></li>
<li><p><strong>pData</strong> – [out] If the allocation and mapping is successful, provides a virtual address through which the memory buffer can be accessed.</p></li>
<li><p><strong>size</strong> – Size of buffer to allocate</p></li>
<li><p><strong>heap</strong> – Implementation defined memory heap selection</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#c.NvError" title="NvError"><code class="xref c c-type docutils literal notranslate"><span class="pre">NvError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaFreeMem">
<a class="reference internal" href="#c.NvError" title="NvError"><span class="n"><span class="pre">NvError</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaFreeMem</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mem_handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pData</span></span>, <span class="n"><span class="pre">NvU32</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaFreeMem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free DMA memory allocated using <a class="reference internal" href="#c.NvDlaAllocMem" title="NvDlaAllocMem"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaAllocMem()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>session_handle</strong> – Session handle address obtained from <a class="reference internal" href="#c.NvDlaInitialize" title="NvDlaInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaInitialize()</span></code></a></p></li>
<li><p><strong>device_handle</strong> – Device handle address obtained from <a class="reference internal" href="#c.NvDlaOpen" title="NvDlaOpen"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaOpen()</span></code></a></p></li>
<li><p><strong>mem_handle</strong> – Memory handle address obtained from <a class="reference internal" href="#c.NvDlaAllocMem" title="NvDlaAllocMem"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaAllocMem()</span></code></a></p></li>
<li><p><strong>pData</strong> – Virtual address returned by <a class="reference internal" href="#c.NvDlaAllocMem" title="NvDlaAllocMem"><code class="xref c c-func docutils literal notranslate"><span class="pre">NvDlaAllocMem()</span></code></a></p></li>
<li><p><strong>size</strong> – Size of the buffer allocated</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#c.NvError" title="NvError"><code class="xref c c-type docutils literal notranslate"><span class="pre">NvError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.NvDlaDebugPrintf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NvDlaDebugPrintf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.NvDlaDebugPrintf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Outputs a message to the debugging console, if present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>format</strong> – A pointer to the format string</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="kernel-mode-driver">
<span id="id3"></span><h2>Kernel Mode Driver<a class="headerlink" href="#kernel-mode-driver" title="Link to this heading">¶</a></h2>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/kmd.png"><img alt="../_images/kmd.png" src="../_images/kmd.png" style="width: 331.09999999999997px; height: 355.59999999999997px;" /></a>
</figure>
<p>The KMD main entry point receives an inference job in memory, selects from multiple available jobs for execution (if on a multi-process system), and submits it to the core engine scheduler. This core engine scheduler is responsible for handling interrupts from <a class="reference internal" href="../glossary.html#term-NVDLA"><span class="xref std std-term">NVDLA</span></a>, scheduling layers on each individual functional block, and updating any dependencies based upon the completion of the layer. The scheduler uses information from the dependency graph to determine when subsequent layers are ready to be scheduled; this allows the compiler to decide scheduling of layers in an optimized way, and avoids performance differences from different implementations of the KMD.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/kmd_interface.png"><img alt="../_images/kmd_interface.png" src="../_images/kmd_interface.png" style="width: 453.59999999999997px; height: 349.29999999999995px;" /></a>
</figure>
<section id="core-engine-interface">
<span id="kmd-interface"></span><h3>Core Engine Interface<a class="headerlink" href="#core-engine-interface" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Neural networks are converted to hardware layers for execution on DLA hardware. These layers are connected to each other using dependency graph and executed on DLA by module known as engine scheduler. This scheduler is responsible for updating dependency counts, handling events and programming hardware layers. It is the core module of DLA software and portable across different OS. Portability layer should use below interfaces to enable core engine module. Core engine module is also referenced as firmware as same source code would be used in firmware of companion controller for headed configs.</p>
</div></blockquote>
<p>General sequence of execution in KMD is as below</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#register-driver"><span class="std std-ref">Register driver with firmware during probe</span></a></p></li>
<li><p><a class="reference internal" href="#task-execute"><span class="std std-ref">Driver submits task information for execution</span></a></p></li>
<li><p><a class="reference internal" href="#driver-interface"><span class="std std-ref">Firmware programs hardware layer</span></a></p></li>
<li><p><a class="reference internal" href="#isr-handler"><span class="std std-ref">Interrupt received from hardware</span></a></p></li>
<li><p><a class="reference internal" href="#bottom-half"><span class="std std-ref">Bottom half caller to process events after interrupt</span></a></p></li>
<li><p><a class="reference internal" href="#clean-task"><span class="std std-ref">Clean task and engine state</span></a></p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="register-driver-with-firmware-during-probe">
<span id="register-driver"></span><h4>Register driver with firmware during probe<a class="headerlink" href="#register-driver-with-firmware-during-probe" title="Link to this heading">¶</a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dla_register_driver">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_register_driver</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">engine_context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function must be called once during boot to initialize DLA engine scheduler and register driver with firmware before submitting any task. Pass pointer to driver context in &#64;param driver_context which is passed as param when firmware calls any function of portability layer. It also updates pointer to engine context which must be passed in any function call to firmware after this point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine_context</strong> – Pointer to engine specific data</p></li>
<li><p><strong>driver_context</strong> – Pointer to driver specific data</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 on success and negative on error</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="driver-submits-task-information-for-execution">
<span id="task-execute"></span><h4>Driver submits task information for execution<a class="headerlink" href="#driver-submits-task-information-for-execution" title="Link to this heading">¶</a></h4>
<dl class="c type">
<dt class="sig sig-object c" id="c.dla_task_descriptor">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_task_descriptor</span></span></span><a class="headerlink" href="#c.dla_task_descriptor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Task descriptor structure. This structure includes all the information required to execute a network such as number of layers, dependency graph address etc.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_execute_task">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_execute_task</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">engine_context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_execute_task" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function initializes sub-engines and starts task execution. Further programming and layer scheduling is triggered by events received from hardware.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine_context</strong> – Engine specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>task_data</strong> – Task specific data to be passed when reading task info</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 on success and negative on error</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="interrupt-received-from-hardware">
<span id="isr-handler"></span><h4>Interrupt received from hardware<a class="headerlink" href="#interrupt-received-from-hardware" title="Link to this heading">¶</a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dla_isr_handler">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_isr_handler</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">engine_context</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_isr_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function is called when DLA interrupt is received. Portability layer should register it’s own handler using the mechanism supported by that platform and call this function from the handler. Call to this function must be protected by lock to prevent handling interrupt when firmware is programming layers in process context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine_context</strong> – Engine specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 on success and negative on error</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="bottom-half-caller-to-process-events-after-interrupt">
<span id="bottom-half"></span><h4>Bottom half caller to process events after interrupt<a class="headerlink" href="#bottom-half-caller-to-process-events-after-interrupt" title="Link to this heading">¶</a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dla_process_events">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_process_events</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">engine_context</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_complete</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_process_events" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interrupt handler just records events and does not process those events. Portability layer must call this function in thread/process context after interrupt handler is done.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine_context</strong> – Engine specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>task_complete</strong> – Pointer to parameter to indicate task complete, firmare writes 1 to it if all layers are processed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 on success and negative on error</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="clean-task-and-engine-state">
<span id="clean-task"></span><h4>Clean task and engine state<a class="headerlink" href="#clean-task-and-engine-state" title="Link to this heading">¶</a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dla_clear_task">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_clear_task</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">engine_context</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_clear_task" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function resets engine scheduler state including op descriptor cache, error values, sub-engine status, events etc and clears previous task state from firmware. This function can be called by portability layer after task completion. It is not mandatory to call it but calling it will ensure clean state before next task execution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine_context</strong> – Engine specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 on success and negative on error</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="kmd-layer">
<span id="id4"></span><h3>Portability layer<a class="headerlink" href="#kmd-layer" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Core engine module (firmware) is OS independent but it still needs some OS services such as memory allocation, read/write IO registers, interrupt notifications. Portability layer implemented in KMD should provide implementation for below interfaces to core engine module.</p>
</div></blockquote>
<section id="firmware-programs-hardware-layer">
<span id="driver-interface"></span><h4>Firmware programs hardware layer<a class="headerlink" href="#firmware-programs-hardware-layer" title="Link to this heading">¶</a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dla_reg_read">
<span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_reg_read</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_reg_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read DLA HW register. Portability layer is responsible to use correct base address and for any IO mapping if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver_context</strong> – Driver specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>addr</strong> – Register offset</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Register value</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_reg_write">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_reg_write</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">reg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_reg_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write DLA HW registr. Portability layer is responsible to use correct base address and for any IO mapping if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver_context</strong> – Driver specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>addr</strong> – Register offset</p></li>
<li><p><strong>reg</strong> – Value to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_read_dma_address">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_read_dma_address</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dla_task_desc</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_desc</span></span>, <span class="n"><span class="pre">int16_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_read_dma_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read DMA address from address list at index specified. This function is used by functional block programming operations to read address for DMA engines in functional blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_desc</strong> – Task descriptor for in execution task</p></li>
<li><p><strong>index</strong> – Index in address list</p></li>
<li><p><strong>dst</strong> – Destination pointer to update address</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 in case success, error code in case of failure</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_read_cpu_address">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_read_cpu_address</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dla_task_desc</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_desc</span></span>, <span class="n"><span class="pre">int16_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_read_cpu_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read CPU accessible address from address list at index specified. This function is used by engine scheduler to read data from memory buffer. Address returned by this function must be accessible by processor running engine scheduler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_desc</strong> – Task descriptor for in execution task</p></li>
<li><p><strong>index</strong> – Index in address list</p></li>
<li><p><strong>dst</strong> – Destination pointer to update address</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 in case success, error code in case of failure</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_data_read">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_data_read</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_data</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_data_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function reads data from buffers passed by UMD in local memory. Addresses for buffers passed by are shared in address list and network descriptor contains index in address list for those buffers. Firmware reads this data from buffer shared by UMD into local buffer to consume the information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver_context</strong> – Driver specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>task_data</strong> – Task specific data received in <a class="reference internal" href="#c.dla_execute_task" title="dla_execute_task"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_execute_task()</span></code></a></p></li>
<li><p><strong>src</strong> – Index in address list</p></li>
<li><p><strong>dst</strong> – Local memory address</p></li>
<li><p><strong>size</strong> – Data size</p></li>
<li><p><strong>offset</strong> – Offset from start of UMD buffer</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 in case success, error code in case of failure</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_data_write">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_data_write</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_data</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">dst</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_data_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function writes data from local buffer to buffer passed by UMD. Addresses for buffers passed by are shared in address list and network descriptor contains index in address list for those buffers. Firmware writes this data to buffer shared by UMD from local buffer to update the information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver_context</strong> – Driver specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>task_data</strong> – Task specific data received in <a class="reference internal" href="#c.dla_execute_task" title="dla_execute_task"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_execute_task()</span></code></a></p></li>
<li><p><strong>src</strong> – Local memory address</p></li>
<li><p><strong>dst</strong> – Index in address list</p></li>
<li><p><strong>size</strong> – Data size</p></li>
<li><p><strong>offset</strong> – Offset from start of UMD buffer</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>0 in case success, error code in case of failure</p>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DESTINATION_PROCESSOR">
<span class="sig-name descname"><span class="n"><span class="pre">DESTINATION_PROCESSOR</span></span></span><a class="headerlink" href="#c.DESTINATION_PROCESSOR" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory will be accessed by processor running firmware.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DESTINATION_DMA">
<span class="sig-name descname"><span class="n"><span class="pre">DESTINATION_DMA</span></span></span><a class="headerlink" href="#c.DESTINATION_DMA" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory will be accessed by NVDLA DMA engines</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_get_dma_address">
<span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_get_dma_address</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver_context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task_data</span></span>, <span class="n"><span class="pre">int16_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst_ptr</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">destination</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_get_dma_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>Some buffers shared by UMD are accessed by processor responsible for programming DLA HW. It would be companion micro-controller in case of headed config while main CPU in case of headless config. Also, some buffers are accessed by DLA DMA engines inside sub-engines. This function should return proper address accessible by destination user depending on config.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver_context</strong> – Driver specific data received in <a class="reference internal" href="#c.dla_register_driver" title="dla_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_register_driver()</span></code></a></p></li>
<li><p><strong>task_data</strong> – Task specific data received in <a class="reference internal" href="#c.dla_execute_task" title="dla_execute_task"><code class="xref c c-func docutils literal notranslate"><span class="pre">dla_execute_task()</span></code></a></p></li>
<li><p><strong>index</strong> – Index in address list</p></li>
<li><p><strong>dst_ptr</strong> – Pointer to update address</p></li>
<li><p><strong>destination</strong> – Destination user for DMA address, <a class="reference internal" href="#c.DESTINATION_PROCESSOR" title="DESTINATION_PROCESSOR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">DESTINATION_PROCESSOR</span></code></a> or <a class="reference internal" href="#c.DESTINATION_DMA" title="DESTINATION_DMA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">DESTINATION_DMA</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_get_time_us">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_get_time_us</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_get_time_us" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read system time in micro-seconds</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Time value in micro-seconds</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_memset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dla_memset</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ch</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_memset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Fills the first len bytes of the memory area pointed to by src with the constant byte ch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> – Memory area address</p></li>
<li><p><strong>ch</strong> – Byte to fill</p></li>
<li><p><strong>len</strong> – Length of memory area to fill</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Memory area address</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_memcpy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dla_memcpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_memcpy" title="Link to this definition">¶</a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dest</strong> – Destination memory area address</p></li>
<li><p><strong>src</strong> – Source memory area address</p></li>
<li><p><strong>len</strong> – Length of memory area to copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Destination memory area address</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_debug">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_debug</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_debug" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print debug message to console</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str</strong> – Format string and variable arguments</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print information message to console</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str</strong> – Format string and variable arguments</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_warn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_warn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_warn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print warning message to console</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str</strong> – Format string and variable arguments</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dla_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dla_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dla_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print error message to console</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str</strong> – Format string and variable arguments</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>
</section>


        </div>
        <div class="col-xs-12 col-md-3">
          
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Runtime environment</a><ul>
<li><a class="reference internal" href="#user-mode-driver">User Mode Driver</a><ul>
<li><a class="reference internal" href="#application-programming-interface">Application Programming Interface</a><ul>
<li><a class="reference internal" href="#runtime-interface">Runtime Interface</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntimeE"><code class="docutils literal notranslate"><span class="pre">IRuntime</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-nvdla-runtime-instance">Create NVDLA runtime instance</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla13createRuntimeEv"><code class="docutils literal notranslate"><span class="pre">createRuntime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#get-nvdla-device-information">Get NVDLA device information</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime13getMaxDevicesEv"><code class="docutils literal notranslate"><span class="pre">getMaxDevices()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime13getNumDevicesEv"><code class="docutils literal notranslate"><span class="pre">getNumDevices()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#load-network-data">Load network data</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime4loadEPK4NvU8i"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#get-input-and-output-tensors-information">Get input and output tensors information</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime18getNumInputTensorsEPi"><code class="docutils literal notranslate"><span class="pre">getNumInputTensors()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime18getInputTensorDescEiP11NvDlaTensor"><code class="docutils literal notranslate"><span class="pre">getInputTensorDesc()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime19getNumOutputTensorsEPi"><code class="docutils literal notranslate"><span class="pre">getNumOutputTensors()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime19getOutputTensorDescEiP11NvDlaTensor"><code class="docutils literal notranslate"><span class="pre">getOutputTensorDesc()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#update-input-and-output-tensors-information">Update input and output tensors information</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime18setInputTensorDescEiPK11NvDlaTensor"><code class="docutils literal notranslate"><span class="pre">setInputTensorDesc()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime19setOutputTensorDescEiPK11NvDlaTensor"><code class="docutils literal notranslate"><span class="pre">setOutputTensorDesc()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#allocate-memory-for-input-and-output-tensors">Allocate memory for input and output tensors</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla20allocateSystemMemoryEPPv5NvU64PPv"><code class="docutils literal notranslate"><span class="pre">allocateSystemMemory()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#bind-memory-handle-with-tensor">Bind memory handle with tensor</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime15bindInputTensorEiPv"><code class="docutils literal notranslate"><span class="pre">bindInputTensor()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime16bindOutputTensorEiPv"><code class="docutils literal notranslate"><span class="pre">bindOutputTensor()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#submit-task-for-inference">Submit task for inference</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime6submitEv"><code class="docutils literal notranslate"><span class="pre">submit()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#unload-network-resources">Unload network resources</a><ul>
<li><a class="reference internal" href="#_CPPv4N5nvdla5nvdla8IRuntime6unloadEi"><code class="docutils literal notranslate"><span class="pre">unload()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#portability-layer">Portability layer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel-mode-driver">Kernel Mode Driver</a><ul>
<li><a class="reference internal" href="#core-engine-interface">Core Engine Interface</a><ul>
<li><a class="reference internal" href="#register-driver-with-firmware-during-probe">Register driver with firmware during probe</a></li>
<li><a class="reference internal" href="#driver-submits-task-information-for-execution">Driver submits task information for execution</a></li>
<li><a class="reference internal" href="#interrupt-received-from-hardware">Interrupt received from hardware</a></li>
<li><a class="reference internal" href="#bottom-half-caller-to-process-events-after-interrupt">Bottom half caller to process events after interrupt</a></li>
<li><a class="reference internal" href="#clean-task-and-engine-state">Clean task and engine state</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kmd-layer">Portability layer</a><ul>
<li><a class="reference internal" href="#firmware-programs-hardware-layer">Firmware programs hardware layer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="compilation_tool.html"
                          title="previous chapter">Compiler library</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="test_application.html"
                          title="next chapter">Test applications</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/sw/runtime_environment.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
        </div>
      </div>
    </div>
  </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <div class="container">
      <div class="row">
      <h3>Navigation</h3>
      <ul>
        <li class="right first">
          <a href="test_application.html" title="Test applications"
             >next</a></li>
        <li class="right">
          <a href="compilation_tool.html" title="Compiler library"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">NVDLA Open Source Project</a>&#187;</li>
        <li class="nav-item nav-item-1"><a href="../contents.html">Documentation</a>&#187;</li>
          <li class="nav-item nav-item-2"><a href="contents.html" >Software Manual</a>&#187;</li> 
      </ul>
      </div>
      </div>
    </div>
<div class="footer" role="contentinfo">
<div class="container">
<div class="row">
&#169; <a
href="../copyright.html">Copyright</a> 2018 - 2026, NVIDIA Corporation.
<a href="https://www.nvidia.com/object/legal_info.html">Legal Information.</a>
<a href="https://www.nvidia.com/object/privacy_policy.html">Privacy Policy.</a>
Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
</div>
</div>
</div>
<script type="text/javascript">_satellite.pageBottom();</script>
  </body>
</html>